<!-- Standalone Generated By Octo (octo-ide.com) -->
<script>data={"program":"###########################################\n#\n#  0x800\n#\n# A Chip8 implementation of the 2048 tile\n#  sliding game\n#\n###########################################\n\n# The high bit of the direction is used by move_tiles to determine whether to reverse the order of bytes (so that the\n#  code can be used to resolve each movement direction).\n# 0_ -> tile set was loaded left to right\n# 1_ -> tile set was loaded right to left and needs to be reversed before/after processing\n# The low bit is used to determine if we're loading a row or a column.\n# _0 -> Loading a row\n# _1 -> Loading a column\n\n:alias DIRECTION v0\n:const FLAG_DIR_REVERSED 0b10\n:const FLAG_DIR_COLUMN   0b01\n:const DIR_RIGHT 0b10 # reversed row\n:const DIR_LEFT  0b00 # normal row\n:const DIR_UP    0b11 #  reversed col\n:const DIR_DOWN  0b01 #  normal col\n\n:alias GAME_STATE vc\n:const VICTORY 1\n\n:alias SPAWNED_TILE_INDEX vd\n:const EMPTY_TILE 0xFF\n:const TRUE 1\n:const FALSE 0\n\n# Gets the two least significant bits from _source and copies them to _dest (leaving source unmodified)\n:macro get_crumb _dest _source { # In: _source; Out: _dest\n\t_dest := 0b11\n\t_dest &= _source\n}\n\n# Shifts _dest right by two bits.\n:macro shift_crumb _dest source { # In: source; Out: _dest\n\t:assert \"Cannot shift into the carry register, the result will be clobbered\" { _dest != vf }\n\t# the first two lines of this macro could be replaced by _dest >>= _source if running on a CHIP8 compliant emulator.\n\t#  Buggy S-CHIP emulators ignore the rhs when shifting so to be safe we explicitly copy.\n\t_dest := source\n\t_dest >>= _dest\n\t_dest >>= _dest\n}\n\n:macro spawn_tile { # Out: SPAWNED_TILE_INDEX; Clobbers: v0-2, vf, i\n\t:assert \"This macro is dummy thicc and should be replaced by a callable function if used more than once\" { CALLS == 0 }\n\t# This procedure jumps to the end state so to save leaving garbage on the call stack it's been implemented as a macro.\n\t# If it ever needs to be converted to a subroutine it would be good to revisit the way the end state is triggered.\n\tv2 := 0\n\t:alias NUM_EMPTIES v1\n\tNUM_EMPTIES := 0\n\n\tloop\n\t\ti := board_data\n\t\ti += v2\n\t\tload v0\n\n\t\tif v0 != EMPTY_TILE then jump spawn_next\n\n\t\t# found an empty tile, add the address to the list of empties\n\t\ti := empty_indexes\n\t\ti += NUM_EMPTIES\n\t\tv0 := v2\n\t\tsave v0\n\t\tNUM_EMPTIES += 1\n\n\t\t: spawn_next\n\t\tv2 += 1\n\t\tif v2 != 16 then\n\tagain\n\n\t# NUM_EMPTIES is now the number of empty tiles and empty_indexes contains the indexes\n\t# If there are no empty spaces then the player has lost and needs to start again\n\tif NUM_EMPTIES == 0 then jump game_end\n\n\t# if there's only one tile then we can skip picking a random spot\n\tif NUM_EMPTIES == 1 then jump single_candidate\n\n\t# Otherwise NUM_EMPTIES is a value from 2 up to a max of 16 (but likely something far less)\n\t#  and we need to find a random index in empty_indexes to fill with a new tile\n\n\t# take shortcuts if NUM_EMPTIES is a power of 2\n\tif NUM_EMPTIES == 16 then jump rand_16\n\n\tif NUM_EMPTIES == 8 then jump rand_8\n\n\tif NUM_EMPTIES == 4 then jump rand_4\n\n\tif NUM_EMPTIES == 2 then jump rand_2\n\n\t# else NUM_EMPTIES is 3, 5, 6, 7, 9, 10, 11, 12, 13, 14, 15\n\t# because I can't be bothered thinking about this more, just copy values from the start of the list to fill it up to 16 entries\n\t#  this does mean that tiles will be more likely to spawn in row 0 than row 3 and within each row slightly more likely to spawn in col 0 than col 3\n\tv2 := 0\n\tloop\n\t\ti := empty_indexes\n\t\ti += v2\n\t\tload v0\n\t\ti := empty_indexes\n\t\ti += NUM_EMPTIES\n\t\tsave v0\n\n\t\tv2 += 1\n\t\tNUM_EMPTIES += 1\n\t\tif NUM_EMPTIES != 16 then\n\tagain\n\n\t# we now have 16 choices, so fall through to the rand_16 case\n\t: rand_16\n\tv0 := random 0b1111\n\tjump load_candidate\n\n\t: rand_8\n\tv0 := random 0b0111\n\tjump load_candidate\n\n\t: rand_4\n\tv0 := random 0b0011\n\tjump load_candidate\n\n\t: rand_2\n\tv0 := random 0b0001\n\tjump load_candidate\n\n\t: single_candidate\n\t# The list of empties only has one choice, so pull the first index\n\tv0 := 0\n\n\t: load_candidate\n\ti := empty_indexes\n\ti += v0\n\tload v0\n\tSPAWNED_TILE_INDEX := v0\n\n\t# spawn tiles at a value of either 2**0 (~7/8 odds) or 2**1 (~1/8 odds)\n\tv0 := random 0b111\n\tif v0 != 1 then v0 := 0\n\n\ti := board_data\n\ti += SPAWNED_TILE_INDEX\n\tsave v0\n}\n\n:macro draw_tile_background _x _y { # Clobbers: vf, i\n\t:assert \"This macro is dummy thicc and should be replaced by a callable function if used more than once\" { CALLS == 0 }\n\t:assert \"This macro clobbers the carry register, do not use it for input\" { ( _x != vf ) & ( _y != vf ) }\n\t_x -= 1\n\t_y -= 1\n\t\n\ti := sprite_block_8\n\tsprite _x _y 7\n\t\n\t_x += 8\n\ti := sprite_block_3\n\tsprite _x _y 7\n\n\t#restore previous values\n\t_x -= 7\n\t_y += 1\n}\n\n:macro draw_digit _digit _x _y { # Clobbers: vf, i\n\ti := hex _digit\n\tsprite _x _y 5\n}\n\n:macro draw_tile _value _index { # In: SPAWNED_TILE_INDEX, Clobbers: v0-3, vf, i\n\t:assert \"This macro is dummy thicc and should be replaced by a callable function if used more than once\" { CALLS == 0 }\n\t:assert \"This macro clobbers registers v0-3, use higher registers for input\" { ( _value > v3 ) & ( _index > v3 ) }\n\t:assert \"This macro clobbers the carry register, do not use it for input\" { ( _value != vf ) & ( _index != vf ) }\n\n\t# Convert the tile value to display value\n\t# Our tile value is treated as an exponent for a power of 2 and displayed as a hex digit followed by a count of 0 digits:\n\t# 2^value = hex value = displayed digits\n\t# 2^+0 = 0x001 = 10\n\t# 2^+1 = 0x002 = 20\n\t# 2^+2 = 0x004 = 40\n\t# 2^+3 = 0x008 = 80\n\t# 2^+4 = 0x010 = 11\n\t# 2^+5 = 0x020 = 21\n\t# 2^+6 = 0x040 = 41\n\t# 2^+7 = 0x080 = 81\n\t# 2^+8 = 0x100 = 12\n\t# 2^+9 = 0x200 = 22\n\t# 2^10 = 0x400 = 42\n\t# 2^11 = 0x800 = 82\n\n\t# get the two least significant bits as these determine our hex digit (1, 2, 4, or 8)\n\tget_crumb v0 _value\n\n\t# at this point v3 is a value from 0-3 but we want a value of 1, 2, 4, or 8. We can use pow(2, v3) to get the right value\n\ti := pow_2_table\n\ti += v0\n\tload v0\n\t:alias HEX_DIGIT v2\n\tHEX_DIGIT := v0\n\n\t# shifting the value right twice will give us the number of 0 digits with no further calculation needed\n\t:alias ZEROS_DIGIT v3\n\tshift_crumb ZEROS_DIGIT _value\n\n\t# multiply the index by two to use for the coordinate lookup\n\tv0 := _index\n\tv0 <<= v0\n\t\n\ti := tile_coordinates\n\ti += v0\n\tload v1\n\t:alias SPRITE_X v0\n\t:alias SPRITE_Y v1\n\n\tif _index != SPAWNED_TILE_INDEX then jump done_background\n\tdraw_tile_background SPRITE_X SPRITE_Y\t\n\t: done_background\n\n\tdraw_digit HEX_DIGIT SPRITE_X SPRITE_Y\n\tSPRITE_X += 5\n\tdraw_digit ZEROS_DIGIT SPRITE_X SPRITE_Y\n}\n\n:macro draw_banner { # Clobbers: v0, vf, i\n\ti := sprite_block_8\n\tv0 := 0\n\tdraw_column\n\n\tv0 := 56\n\tdraw_column\n}\n\n:macro draw_victory_banner { # Clobbers: v0, vf, i\n\ti := sprite_numeral_2_6\n\tv0 := 0\n\tvf := 0\n\tsprite vf v0 8\n\tvf := 56\n\tsprite vf v0 8\n\n\ti := sprite_numeral_0_6\n\tv0 := 8\n\tvf := 0\n\tsprite vf v0 8\n\tvf := 56\n\tsprite vf v0 8\n\n\ti := sprite_numeral_4_6\n\tv0 := 16\n\tvf := 0\n\tsprite vf v0 8\n\tvf := 56\n\tsprite vf v0 8\n\n\ti := sprite_numeral_8_6\n\tv0 := 24\n\tvf := 0\n\tsprite vf v0 8\n\tvf := 56\n\tsprite vf v0 8\n}\n\n:macro draw_board { # Clobbers: v0-4, vf, i\n\t:assert \"This macro is dummy thicc and should be replaced by a callable function if used more than once\" { CALLS == 0 }\n\t# wait until the specified delay since the last frame was drawn\n\tloop\n\t\tvf := delay\n\t\tif vf != 0 then\n\tagain\n\n\tclear\n\n\tif GAME_STATE == VICTORY then jump victory_banner\n\n\tdraw_banner\n\tjump done_banner\n\t\n\t: victory_banner\n\tdraw_victory_banner\n\n\t: done_banner\n\t# Loop over board\n\t# when a non-empty space is found, draw the current value\n\t:alias INDEX v4\n\tINDEX := 0\n\tloop\n\t\ti := board_data\n\t\ti += INDEX\n\n\t\t:alias VALUE v5\n\t\tload v0\n\t\tVALUE := v0\n\n\t\tif VALUE == EMPTY_TILE then jump draw_board_next\n\t\t\n\t\tdraw_tile VALUE INDEX\n\n\t\t: draw_board_next\n\t\tINDEX += 1\n\t\tif INDEX != 16 then\n\tagain\n\n\t# cap framerate at 20 fps\n\tvf := 3\n\tdelay := vf\n}\n\n:macro buzz { # Clobbers: vf\n\tvf := 4\n\tbuzzer := vf\n}\n\n:macro get_input { # Out: DIRECTION; Clobbers: vf\n\t:assert \"This macro is dummy thicc and should be replaced by a callable function if used more than once\" { CALLS == 0 }\n\t:const DIR_NONE -1\n\tDIRECTION := DIR_NONE\n\t\n\tloop\n\t\t# Block till a key is pressed, game state only advances when the player makes a valid move\n\t\tvf := key\n\n\t\tif vf == OCTO_KEY_W then DIRECTION := DIR_UP\n\n\t\tif vf == OCTO_KEY_A then DIRECTION := DIR_LEFT\n\n\t\tif vf == OCTO_KEY_S then DIRECTION := DIR_DOWN\n\n\t\tif vf == OCTO_KEY_D then DIRECTION := DIR_RIGHT\n\n\t\twhile DIRECTION == DIR_NONE\n\t\t# An invalid key was pressed, trigger the buzzer and wait for a new key press\n\t\tbuzz\n\tagain\n}\n\n:macro multiply_by_four _target { # In/Out: _target; Clobbers: vf\n\t:assert \"Cannot multiply the carry register, the result will be clobbered\" { _target != vf }\n\t_target <<= _target\n\t_target <<= _target\n}\n\n:macro resolve_collision _target {\n\t:assert \"Collision resolution is only applicable for registers 0-2\" { _target < v3 }\n\t_target += 1\n\tif _target == 11 then GAME_STATE := VICTORY # 2^11 is 2048\n}\n\n:macro process_tiles { # In: v0-3\n\t# v0, v1, v2, v3 contain a collection of tiles that are treated as moving toward v0\n\t#  (the caller will map from/to the actual saved order)\n\n\t# move tiles to the leftmost edge\n\tif v2 == EMPTY_TILE then slide_onto_v2\n\tif v1 == EMPTY_TILE then slide_onto_v1\n\tif v0 == EMPTY_TILE then slide_onto_v0\n\n\t# shifted everything to the left, so check for collisions\n\tif v0 == EMPTY_TILE then jump done_processing\n\tif v0 != v1 then jump check_v1\n\t# collision between v0 and v1\n\tresolve_collision v0\n\tslide_onto_v1\n\t: check_v1\n\tif v1 == EMPTY_TILE then jump done_processing\n\tif v1 != v2 then jump check_v2\n\t#collision between v1 and v2\n\tresolve_collision v1\n\tslide_onto_v2\n\t: check_v2\n\tif v2 == EMPTY_TILE then jump done_processing\n\tif v2 != v3 then jump done_processing\n\t# collision between v2 and v3\n\tresolve_collision v2\n\tslide_onto_v3\n\t: done_processing\n}\n\n:macro move_board { # In: DIRECTION; Out: GAME_STATE; Clobbers: v0-v7, vf, i\n\t:alias LOOP_COUNTER v4\n\tLOOP_COUNTER := 0\n\n\t:alias IS_REVERSED v5\n\tIS_REVERSED := FLAG_DIR_REVERSED\n\tIS_REVERSED &= DIRECTION\n\n\t:alias IS_COLUMN v6\n\tIS_COLUMN := FLAG_DIR_COLUMN\n\tIS_COLUMN &= DIRECTION\n\n\t: move_loop\n\t\t:alias LOAD_OFFSET v7\n\t\tLOAD_OFFSET := LOOP_COUNTER\n\n\t\tif IS_COLUMN == FLAG_DIR_COLUMN then jump load_column\n\n\t\t# load_row\n\t\tmultiply_by_four LOAD_OFFSET\n\t\t\n\t\ti := board_data\n\t\ti += LOAD_OFFSET\n\t\tload v3 # load the current values for TILE_0 to TILE_3\n\t\tjump end_load\n\t\t\n\t\t: load_column\n\t\t:const STRIDE 4\n\t\ti := board_data\n\t\ti += LOAD_OFFSET\n\t\tload v0\n\t\tv3 := v0\n\n\t\tLOAD_OFFSET += STRIDE\n\t\ti := board_data\n\t\ti += LOAD_OFFSET\n\t\tload v0\n\t\tv2 := v0\n\n\t\tLOAD_OFFSET += STRIDE\n\t\ti := board_data\n\t\ti += LOAD_OFFSET\n\t\tload v0\n\t\tv1 := v0\n\n\t\tLOAD_OFFSET += STRIDE\n\t\ti := board_data\n\t\ti += LOAD_OFFSET\n\t\tload v0\n\t\t: end_load\n\n\t\tif IS_REVERSED == FLAG_DIR_REVERSED then reverse\n\t\t\n\t\tprocess_tiles\n\t\t\n\t\tif IS_REVERSED == FLAG_DIR_REVERSED then reverse\n\n\t\tif IS_COLUMN == FLAG_DIR_COLUMN then jump save_column\n\n\t\t# save_row\n\t\ti := board_data\n\t\ti += LOAD_OFFSET\n\t\tsave v3 # save the new values for TILE_0 to TILE_3\n\t\tjump end_save\n\n\t\t: save_column\n\t\ti := board_data\n\t\ti += LOAD_OFFSET\n\t\tsave v0\n\n\t\tLOAD_OFFSET -= STRIDE\n\t\ti := board_data\n\t\ti += LOAD_OFFSET\n\t\tv0 := v1\n\t\tsave v0\n\n\t\tLOAD_OFFSET -= STRIDE\n\t\ti := board_data\n\t\ti += LOAD_OFFSET\n\t\tv0 := v2\n\t\tsave v0\n\n\t\tLOAD_OFFSET -= STRIDE\n\t\ti := board_data\n\t\ti += LOAD_OFFSET\n\t\tv0 := v3\n\t\tsave v0\n\t\t: end_save\n\t\t\n\t\tLOOP_COUNTER += 1\n\t\tif LOOP_COUNTER != 4 then jump move_loop\n\tjump game_loop\n}\n\n:macro draw_lose_banner { # Clobbers: v0, vf, i\n\tv0 := 0\n\ti := sprite_letter_g_6\n\tvf := 0\n\tsprite v0 vf 8\n\ti := sprite_letter_a_6\n\tvf := 8\n\tsprite v0 vf 8\n\ti := sprite_letter_m_6\n\tvf := 16\n\tsprite v0 vf 8\n\ti := sprite_letter_e_6\n\tvf := 24\n\tsprite v0 vf 8\n\n\tv0 := 56\n\ti := sprite_letter_o_6\n\tvf := 0\n\tsprite v0 vf 8\n\ti := sprite_letter_v_6\n\tvf := 8\n\tsprite v0 vf 8\n\ti := sprite_letter_e_6\n\tvf := 16\n\tsprite v0 vf 8\n\ti := sprite_letter_r_6\n\tvf := 24\n\tsprite v0 vf 8\n}\n\n############################\n# Main/Game Loop\n############################\n: main\n\t# clear board_data\n\tv0 := EMPTY_TILE\n\tv1 := 0\n\tloop\n\t\ti := board_data\n\t\ti += v1\n\t\tsave v0\n\t\tv1 += 1\n\t\tif v1 != 16 then\n\tagain\n\n\tGAME_STATE := 0\n\n\t: game_loop\n\t\tspawn_tile # spawn_tile will jump to game_end if it can't find a free space\n\n\t\tdraw_board\n\n\t\tget_input\n\n\t\tmove_board\n\t# move_board jumps to game_loop\n\n\t# No free spaces for tiles, restart the game\n\t: game_end\n\tif GAME_STATE == VICTORY then jump done_lose_banner\n\tdraw_lose_banner\n\t: done_lose_banner\n\tbuzz\n\tvf := key\njump main\n\n:macro swap _a _b { # Clobbers: vf\n\t:assert \"Swapping a register with itself is a useless operation\" { _a != _b }\n\t:assert \"Using the carry register as operand _a in a swap will clobber it with the value from _b\" { _a != vf }\n\t:assert \"Using the carry register as operand _b in a swap will clobber it with the value from _a\" { _b != vf }\n\tvf := _a\n\t_a := _b\n\t_b := vf\n}\n\n: reverse # In: v0-3; Clobbers: vf\n\tswap v0 v3\n\tswap v1 v2\nreturn\n\n# The following set of labels are intended to be used as subroutines which deliberately fall through, as this simplifies the logic in process_tiles\n: slide_onto_v0 # In: v0-3\n\tv0 := v1\n: slide_onto_v1 # In: v1-3\n\tv1 := v2\n: slide_onto_v2 # In: v2-3\n\tv2 := v3\n: slide_onto_v3 # In: v3\n\tv3 := EMPTY_TILE\nreturn\n\n: draw_column # In: v0, i; Clobbers: vf\n\t# Draws the first 8 rows of the sprite pointed to by i from the top to the bottom of the screen (so repeated 4 times)\n\t#  using v0 as the x-coord\n\tvf := 0\n\tsprite v0 vf 8\n\tvf := 8\n\tsprite v0 vf 8\n\tvf := 16\n\tsprite v0 vf 8\n\tvf := 24\n\tsprite v0 vf 8\nreturn\n\n: sprite_block_8\n\t0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF # a solid block (8x8 pixels)\n: sprite_block_3\n\t0xE0 0xE0 0xE0 0xE0 0xE0 0xE0 0xE0 0xE0 # a 3 wide block (8x3 pixels)\n#: sprite_checker_8\n#\t0x55 0xAA 0x55 0xAA 0x55 0xAA 0x55 0xAA\n: sprite_numeral_0_6\n\t0x00 0x7C 0x7E 0x66 0x66 0x7E 0x3E #0x00\n: sprite_numeral_2_6\n\t0x00 0x3C 0x46 0x0C 0x18 0x30 0x7E #0x00\n: sprite_numeral_4_6\n\t0x00 0x64 0x66 0x7E 0x3E 0x06 0x06 #0x00\n: sprite_numeral_8_6\n\t0x00 0x7C 0x66 0x7E 0x66 0x66 0x3E #0x00\n: sprite_letter_a_6\n\t0x00 0x3C 0x66 0x66 0x7E 0x66 0x62 #0x00\n: sprite_letter_e_6\n\t0x00 0x3C 0x60 0x78 0x60 0x60 0x3C #0x00\n: sprite_letter_g_6\n\t0x00 0x3C 0x72 0x60 0x66 0x72 0x3C #0x00\n: sprite_letter_m_6\n\t0x00 0x62 0x76 0x7E 0x6A 0x62 0x62 #0x00\n: sprite_letter_o_6\n\t0x00 0x3C 0x76 0x62 0x62 0x76 0x3C #0x00\n: sprite_letter_r_6\n\t0x00 0x7C 0x62 0x62 0x7C 0x66 0x62 #0x00\n: sprite_letter_v_6\n\t0x00 0x42 0x62 0x66 0x34 0x3C 0x18 0x00\n\n: pow_2_table\n\t1 2 4 8 # 2**0, 2**1, 2**2, 2**3 - used by the draw_tile routine\n\n\t# Tiles are 11 pixels wide and 7 pixels high, digits are using the default 4x5 font\n\t# 0123456789A\n\t# 1#  # ####\n\t# 2#  # #  #\n\t# 3#### #  #\n\t# 4   # #  #\n\t# 5   # ####\n\t# 6\n\t#\n\t# The game board is centered on the screen, leaving a 2 pixel border around it and an additional 8 pixel gutter on the left and right sides of the screen\n: tile_coordinates\n\t# store the precalculated x/y coordinate pairs for the top left corner of a tile based on the index.\n\t# lookups will multiply by 2 given the coordinates take up two bytes\n\t0x0B 0x02 0x16 0x02 0x21 0x02 0x2C 0x02\n\t0x0B 0x09 0x16 0x09 0x21 0x09 0x2C 0x09\n\t0x0B 0x10 0x16 0x10 0x21 0x10 0x2C 0x10\n\t0x0B 0x17 0x16 0x17 0x21 0x17 0x2C 0x17\n\t# This data was calculated with the following stringmode definition:\n\t#:stringmode tile_coords \"0123456789ABCDEF\" {\n\t\t## x coordinate is left gutter + left border + (tile width * the low crumb of the index) + a one pixel offset as we're drawing the numbers only most of the time\n\t\t#:byte { 8 + 2 + ( 11 * ( VALUE & 0b11 ) ) + 1 }\n\n\t\t## y coordinate is top border + (tile height * bits 2-3 of the index) + a one pixel offset again because drawing the numbers is the common case\n\t\t#:byte { 2 + ( 7 * ( VALUE >> 2 ) ) }\n\t#}\n\t#tile_coords \"0123456789ABCDEF\"\n\n: board_data # This data gets initialised to EMPTY_TILE at runtime\n\t0xCC 0x77 0xCC 0x77\n\t0xCC 0x77 0xCC 0x77\n\t0xCC 0x77 0xCC 0x77\n\t0xCC 0x77 0xCC 0x77\n:monitor board_data \"%i, %i, %i, %i\\n%i, %i, %i, %i\\n%i, %i, %i, %i\\n%i, %i, %i, %i\\n\"\n\n: empty_indexes\n\t0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00\n","options":{"tickrate":30,"fillColor":"#FF00FF","fillColor2":"#00FFFF","blendColor":"#FFFFFF","backgroundColor":"#000000","buzzColor":"#990099","quietColor":"#330033","shiftQuirks":false,"loadStoreQuirks":false,"vfOrderQuirks":false,"clipQuirks":false,"vBlankQuirks":false,"jumpQuirks":false,"screenRotation":0,"maxSize":3584,"touchInputMode":"swipe","logicQuirks":false,"fontStyle":"octo","displayScale":"4"},"rom":[96,255,97,0,164,230,241,30,240,85,113,1,49,16,18,4,108,0,98,0,97,0,164,230,242,30,240,101,48,255,18,42,164,246,241,30,128,32,240,85,113,1,114,1,50,16,18,22,65,0,19,250,65,1,18,110,65,16,18,94,65,8,18,98,65,4,18,102,65,2,18,106,98,0,164,246,242,30,240,101,164,246,241,30,240,85,114,1,113,1,49,16,18,74,192,15,18,112,192,7,18,112,192,3,18,112,192,1,18,112,96,0,164,246,240,30,240,101,141,0,192,7,48,1,96,0,164,230,253,30,240,85,255,7,63,0,18,132,0,224,76,1,18,156,164,100,96,0,36,82,96,56,36,82,18,204,164,123,96,0,111,0,223,8,111,56,223,8,164,116,96,8,111,0,223,8,111,56,223,8,164,130,96,16,111,0,223,8,111,56,223,8,164,137,96,24,111,0,223,8,111,56,223,8,100,0,164,230,244,30,240,101,133,0,69,255,19,22,96,3,128,82,164,194,240,30,240,101,130,0,131,80,131,54,131,54,128,64,128,14,164,198,240,30,241,101,84,208,19,12,112,255,113,255,164,100,208,23,112,8,164,108,208,23,112,249,113,1,242,41,208,21,112,5,243,41,208,21,116,1,52,16,18,206,111,3,255,21,96,255,255,10,79,5,96,3,79,7,96,0,79,8,96,1,79,9,96,2,48,255,19,62,111,4,255,24,19,34,100,0,101,2,133,2,102,1,134,2,135,64,70,1,19,90,135,126,135,126,164,230,247,30,243,101,19,126,164,230,247,30,240,101,131,0,119,4,164,230,247,30,240,101,130,0,119,4,164,230,247,30,240,101,129,0,119,4,164,230,247,30,240,101,69,2,36,58,66,255,36,76,65,255,36,74,64,255,36,72,64,255,19,190,80,16,19,158,112,1,64,11,108,1,36,74,65,255,19,190,81,32,19,174,113,1,65,11,108,1,36,76,66,255,19,190,82,48,19,190,114,1,66,11,108,1,36,78,69,2,36,58,70,1,19,206,164,230,247,30,243,85,19,242,164,230,247,30,240,85,119,252,164,230,247,30,128,16,240,85,119,252,164,230,247,30,128,32,240,85,119,252,164,230,247,30,128,48,240,85,116,1,52,4,19,72,18,18,76,1,20,50,96,0,164,158,111,0,208,248,164,144,111,8,208,248,164,165,111,16,208,248,164,151,111,24,208,248,96,56,164,172,111,0,208,248,164,186,111,8,208,248,164,151,111,16,208,248,164,179,111,24,208,248,111,4,255,24,255,10,18,0,143,0,128,48,131,240,143,16,129,32,130,240,0,238,128,16,129,32,130,48,99,255,0,238,111,0,208,248,111,8,208,248,111,16,208,248,111,24,208,248,0,238,255,255,255,255,255,255,255,255,224,224,224,224,224,224,224,224,0,124,126,102,102,126,62,0,60,70,12,24,48,126,0,100,102,126,62,6,6,0,124,102,126,102,102,62,0,60,102,102,126,102,98,0,60,96,120,96,96,60,0,60,114,96,102,114,60,0,98,118,126,106,98,98,0,60,118,98,98,118,60,0,124,98,98,124,102,98,0,66,98,102,52,60,24,0,1,2,4,8,11,2,22,2,33,2,44,2,11,9,22,9,33,9,44,9,11,16,22,16,33,16,44,16,11,23,22,23,33,23,44,23,204,119,204,119,204,119,204,119,204,119,204,119,204,119,204,119,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}</script>
<script>"use strict";

function invertKeymap(k) {
	return Object.keys(k).reduce((a,b) => {
		Object.keys(k[b]).forEach(x => a[x]=+b)
		return a
	}, {})
}

function getPref(key) {
	try { return JSON.parse(localStorage.getItem(key)) }
	catch(e) { console.log(e); return null }
}
function setPref(key, value) {
	try { localStorage.setItem(key, JSON.stringify(value)) }
	catch(e) { console.log(e); }
}

var keymap = (this.STATIC_KEYMAP) || getPref('octoKeymap') || {
	0x0: { x:1 },
	0x1: { 1:1 },
	0x2: { 2:1 },
	0x3: { 3:1 },
	0x4: { q:1 },
	0x5: { w:1, ArrowUp:1 },
	0x6: { e:1, ' ':1 },
	0x7: { a:1, ArrowLeft:1 },
	0x8: { s:1, ArrowDown:1 },
	0x9: { d:1, ArrowRight:1 },
	0xA: { z:1 },
	0xB: { c:1 },
	0xC: { 4:1 },
	0xD: { r:1 },
	0xE: { f:1 },
	0xF: { v:1 },
}

var keymapInverse = invertKeymap(keymap)

var smallfonts = {
	octo: [
		0xF0, 0x90, 0x90, 0x90, 0xF0, // 0
		0x20, 0x60, 0x20, 0x20, 0x70, // 1
		0xF0, 0x10, 0xF0, 0x80, 0xF0, // 2
		0xF0, 0x10, 0xF0, 0x10, 0xF0, // 3
		0x90, 0x90, 0xF0, 0x10, 0x10, // 4
		0xF0, 0x80, 0xF0, 0x10, 0xF0, // 5
		0xF0, 0x80, 0xF0, 0x90, 0xF0, // 6
		0xF0, 0x10, 0x20, 0x40, 0x40, // 7
		0xF0, 0x90, 0xF0, 0x90, 0xF0, // 8
		0xF0, 0x90, 0xF0, 0x10, 0xF0, // 9
		0xF0, 0x90, 0xF0, 0x90, 0x90, // A
		0xE0, 0x90, 0xE0, 0x90, 0xE0, // B
		0xF0, 0x80, 0x80, 0x80, 0xF0, // C
		0xE0, 0x90, 0x90, 0x90, 0xE0, // D
		0xF0, 0x80, 0xF0, 0x80, 0xF0, // E
		0xF0, 0x80, 0xF0, 0x80, 0x80, // F
	],
	vip: [
		0xF0, 0x90, 0x90, 0x90, 0xF0,
		0x60, 0x20, 0x20, 0x20, 0x70,
		0xF0, 0x10, 0xF0, 0x80, 0xF0,
		0xF0, 0x10, 0xF0, 0x10, 0xF0,
		0xA0, 0xA0, 0xF0, 0x20, 0x20,
		0xF0, 0x80, 0xF0, 0x10, 0xF0,
		0xF0, 0x80, 0xF0, 0x90, 0xF0,
		0xF0, 0x10, 0x10, 0x10, 0x10,
		0xF0, 0x90, 0xF0, 0x90, 0xF0,
		0xF0, 0x90, 0xF0, 0x10, 0xF0,
		0xF0, 0x90, 0xF0, 0x90, 0x90,
		0xF0, 0x50, 0x70, 0x50, 0xF0,
		0xF0, 0x80, 0x80, 0x80, 0xF0,
		0xF0, 0x50, 0x50, 0x50, 0xF0,
		0xF0, 0x80, 0xF0, 0x80, 0xF0,
		0xF0, 0x80, 0xF0, 0x80, 0x80,
	],
	dream6800: [
		0xE0, 0xA0, 0xA0, 0xA0, 0xE0,
		0x40, 0x40, 0x40, 0x40, 0x40,
		0xE0, 0x20, 0xE0, 0x80, 0xE0,
		0xE0, 0x20, 0xE0, 0x20, 0xE0,
		0x80, 0xA0, 0xA0, 0xE0, 0x20,
		0xE0, 0x80, 0xE0, 0x20, 0xE0,
		0xE0, 0x80, 0xE0, 0xA0, 0xE0,
		0xE0, 0x20, 0x20, 0x20, 0x20,
		0xE0, 0xA0, 0xE0, 0xA0, 0xE0,
		0xE0, 0xA0, 0xE0, 0x20, 0xE0,
		0xE0, 0xA0, 0xE0, 0xA0, 0xA0,
		0xC0, 0xA0, 0xE0, 0xA0, 0xC0,
		0xE0, 0x80, 0x80, 0x80, 0xE0,
		0xC0, 0xA0, 0xA0, 0xA0, 0xC0,
		0xE0, 0x80, 0xE0, 0x80, 0xE0,
		0xE0, 0x80, 0xC0, 0x80, 0x80,
	],
	eti660: [
		0xE0, 0xA0, 0xA0, 0xA0, 0xE0,
		0x20, 0x20, 0x20, 0x20, 0x20,
		0xE0, 0x20, 0xE0, 0x80, 0xE0,
		0xE0, 0x20, 0xE0, 0x20, 0xE0,
		0xA0, 0xA0, 0xE0, 0x20, 0x20,
		0xE0, 0x80, 0xE0, 0x20, 0xE0,
		0xE0, 0x80, 0xE0, 0xA0, 0xE0,
		0xE0, 0x20, 0x20, 0x20, 0x20,
		0xE0, 0xA0, 0xE0, 0xA0, 0xE0,
		0xE0, 0xA0, 0xE0, 0x20, 0xE0,
		0xE0, 0xA0, 0xE0, 0xA0, 0xA0,
		0x80, 0x80, 0xE0, 0xA0, 0xE0,
		0xE0, 0x80, 0x80, 0x80, 0xE0,
		0x20, 0x20, 0xE0, 0xA0, 0xE0,
		0xE0, 0x80, 0xE0, 0x80, 0xE0,
		0xE0, 0x80, 0xC0, 0x80, 0x80,
	],
	fish: [
		0x60, 0xA0, 0xA0, 0xA0, 0xC0,
		0x40, 0xC0, 0x40, 0x40, 0xE0,
		0xC0, 0x20, 0x40, 0x80, 0xE0,
		0xC0, 0x20, 0x40, 0x20, 0xC0,
		0x20, 0xA0, 0xE0, 0x20, 0x20,
		0xE0, 0x80, 0xC0, 0x20, 0xC0,
		0x40, 0x80, 0xC0, 0xA0, 0x40,
		0xE0, 0x20, 0x60, 0x40, 0x40,
		0x40, 0xA0, 0x40, 0xA0, 0x40,
		0x40, 0xA0, 0x60, 0x20, 0x40,
		0x40, 0xA0, 0xE0, 0xA0, 0xA0,
		0xC0, 0xA0, 0xC0, 0xA0, 0xC0,
		0x60, 0x80, 0x80, 0x80, 0x60,
		0xC0, 0xA0, 0xA0, 0xA0, 0xC0,
		0xE0, 0x80, 0xC0, 0x80, 0xE0,
		0xE0, 0x80, 0xC0, 0x80, 0x80,
	],
}
var bigfonts = {
	octo: [
		0xFF, 0xFF, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xFF, 0xFF, // 0
		0x18, 0x78, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0xFF, 0xFF, // 1
		0xFF, 0xFF, 0x03, 0x03, 0xFF, 0xFF, 0xC0, 0xC0, 0xFF, 0xFF, // 2
		0xFF, 0xFF, 0x03, 0x03, 0xFF, 0xFF, 0x03, 0x03, 0xFF, 0xFF, // 3
		0xC3, 0xC3, 0xC3, 0xC3, 0xFF, 0xFF, 0x03, 0x03, 0x03, 0x03, // 4
		0xFF, 0xFF, 0xC0, 0xC0, 0xFF, 0xFF, 0x03, 0x03, 0xFF, 0xFF, // 5
		0xFF, 0xFF, 0xC0, 0xC0, 0xFF, 0xFF, 0xC3, 0xC3, 0xFF, 0xFF, // 6
		0xFF, 0xFF, 0x03, 0x03, 0x06, 0x0C, 0x18, 0x18, 0x18, 0x18, // 7
		0xFF, 0xFF, 0xC3, 0xC3, 0xFF, 0xFF, 0xC3, 0xC3, 0xFF, 0xFF, // 8
		0xFF, 0xFF, 0xC3, 0xC3, 0xFF, 0xFF, 0x03, 0x03, 0xFF, 0xFF, // 9
		0x7E, 0xFF, 0xC3, 0xC3, 0xC3, 0xFF, 0xFF, 0xC3, 0xC3, 0xC3, // A
		0xFC, 0xFC, 0xC3, 0xC3, 0xFC, 0xFC, 0xC3, 0xC3, 0xFC, 0xFC, // B
		0x3C, 0xFF, 0xC3, 0xC0, 0xC0, 0xC0, 0xC0, 0xC3, 0xFF, 0x3C, // C
		0xFC, 0xFE, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xFE, 0xFC, // D
		0xFF, 0xFF, 0xC0, 0xC0, 0xFF, 0xFF, 0xC0, 0xC0, 0xFF, 0xFF, // E
		0xFF, 0xFF, 0xC0, 0xC0, 0xFF, 0xFF, 0xC0, 0xC0, 0xC0, 0xC0  // F
	],
	schip: [
		0x3C, 0x7E, 0xE7, 0xC3, 0xC3, 0xC3, 0xC3, 0xE7, 0x7E, 0x3C,
		0x18, 0x38, 0x58, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C,
		0x3E, 0x7F, 0xC3, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xFF, 0xFF,
		0x3C, 0x7E, 0xC3, 0x03, 0x0E, 0x0E, 0x03, 0xC3, 0x7E, 0x3C,
		0x06, 0x0E, 0x1E, 0x36, 0x66, 0xC6, 0xFF, 0xFF, 0x06, 0x06,
		0xFF, 0xFF, 0xC0, 0xC0, 0xFC, 0xFE, 0x03, 0xC3, 0x7E, 0x3C,
		0x3E, 0x7C, 0xE0, 0xC0, 0xFC, 0xFE, 0xC3, 0xC3, 0x7E, 0x3C,
		0xFF, 0xFF, 0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x60, 0x60,
		0x3C, 0x7E, 0xC3, 0xC3, 0x7E, 0x7E, 0xC3, 0xC3, 0x7E, 0x3C,
		0x3C, 0x7E, 0xC3, 0xC3, 0x7F, 0x3F, 0x03, 0x03, 0x3E, 0x7C,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // no hex chars!
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	],
	fish: [
		0x7C, 0xC6, 0xCE, 0xDE, 0xD6, 0xF6, 0xE6, 0xC6, 0x7C, 0x00, // at most 7x9 pixels!
		0x10, 0x30, 0xF0, 0x30, 0x30, 0x30, 0x30, 0x30, 0xFC, 0x00,
		0x78, 0xCC, 0xCC, 0x0C, 0x18, 0x30, 0x60, 0xCC, 0xFC, 0x00,
		0x78, 0xCC, 0x0C, 0x0C, 0x38, 0x0C, 0x0C, 0xCC, 0x78, 0x00,
		0x0C, 0x1C, 0x3C, 0x6C, 0xCC, 0xFE, 0x0C, 0x0C, 0x1E, 0x00,
		0xFC, 0xC0, 0xC0, 0xC0, 0xF8, 0x0C, 0x0C, 0xCC, 0x78, 0x00,
		0x38, 0x60, 0xC0, 0xC0, 0xF8, 0xCC, 0xCC, 0xCC, 0x78, 0x00,
		0xFE, 0xC6, 0xC6, 0x06, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x00,
		0x78, 0xCC, 0xCC, 0xEC, 0x78, 0xDC, 0xCC, 0xCC, 0x78, 0x00,
		0x7C, 0xC6, 0xC6, 0xC6, 0x7C, 0x18, 0x18, 0x30, 0x70, 0x00,
		0x30, 0x78, 0xCC, 0xCC, 0xCC, 0xFC, 0xCC, 0xCC, 0xCC, 0x00,
		0xFC, 0x66, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x66, 0xFC, 0x00,
		0x3C, 0x66, 0xC6, 0xC0, 0xC0, 0xC0, 0xC6, 0x66, 0x3C, 0x00,
		0xF8, 0x6C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x6C, 0xF8, 0x00,
		0xFE, 0x62, 0x60, 0x64, 0x7C, 0x64, 0x60, 0x62, 0xFE, 0x00,
		0xFE, 0x66, 0x62, 0x64, 0x7C, 0x64, 0x60, 0x60, 0xF0, 0x00,
	],
	none: new Array(16*10).fill(0x00),
}
var fontsets = {
	octo     : { small: smallfonts.octo,      big: bigfonts.octo  },
	vip      : { small: smallfonts.vip,       big: bigfonts.none  },
	dream6800: { small: smallfonts.dream6800, big: bigfonts.none  },
	eti660   : { small: smallfonts.eti660,    big: bigfonts.none  },
	schip    : { small: smallfonts.octo,      big: bigfonts.schip },
	fish     : { small: smallfonts.fish,      big: bigfonts.fish  },
}

////////////////////////////////////
//
//   The Chip8 Interpreter:
//
////////////////////////////////////

function Emulator() {

	// persistent configuration settings
	this.tickrate           = 20;
	this.fillColor          = "#FFCC00";
	this.fillColor2         = "#FF6600";
	this.blendColor         = "#662200";
	this.backgroundColor    = "#996600";
	this.buzzColor          = "#FFAA00";
	this.quietColor         = "#000000";
	this.shiftQuirks        = false;
	this.loadStoreQuirks    = false;
	this.vfOrderQuirks      = false;
	this.clipQuirks         = false;
	this.jumpQuirks         = false;
	this.logicQuirks        = false;
	this.vBlankQuirks       = false;
	this.enableXO           = true;
	this.screenRotation     = 0;//must be 0, 90, 180, or 270
	this.maxSize            = 3584;
	this.touchInputMode     = 'none';
	this.maskFormatOverride = true;
	this.numericFormatStr   = "default";
	this.fontStyle          = 'octo';

	// interpreter state
	this.p  = [[],[]];  // pixels
	this.m  = [];       // memory (bytes)
	this.r  = [];       // return stack
	this.v  = [];       // registers
	this.pc = 0;        // program counter
	this.i  = 0;        // index register
	this.dt = 0;        // delay timer
	this.st = 0;        // sound timer
	this.hires = false; // are we in SuperChip high res mode?
	this.flags = [];    // semi-persistent hp48 flag vars
	this.pattern = [];  // audio pattern buffer
	this.plane = 1;     // graphics plane
	this.profile_data = {};

	// control/debug state
	this.keys = {};       // track keys which are pressed
	this.waiting = false; // are we waiting for a keypress?
	this.waitReg = -1;    // destination register of an awaited key
	this.halted = true;
	this.breakpoint = false;
	this.metadata = {};
	this.tickCounter = 0;
	this.linted = false;

	// external interface stubs
	this.exitVector  = function() {}                                   // fired by 'exit'
	this.importFlags = function() { return [0, 0, 0, 0, 0, 0, 0, 0]; } // load persistent flags
	this.exportFlags = function(flags) {}                              // save persistent flags
	this.buzzTrigger = function(ticks, remainingTicks) {}                              // fired when buzzer played

	this.init = function(rom) {
		// initialise memory with a new array to ensure that it is of the right size and is initiliased to 0
		this.m = this.enableXO ? new Uint8Array(0x10000) : new Uint8Array(0x1000);

		this.p = [[], []];
		if (this.enableXO)
			for(var z = 0; z < 64*128; z++) { this.p[0][z] = 0; this.p[1][z] = 0; }
		else
			for(var z = 0; z < 32*64; z++) { this.p[0][z] = 0; this.p[1][z] = 0; }

		// initialize memory
		var font = fontsets[this.fontStyle];
		for(var z = 0; z < 32*64;            z++) { this.p[0][z] = 0; this.p[1][z] = 0; }
		for(var z = 0; z < font.small.length;z++) { this.m[z] = font.small[z]; }
		for(var z = 0; z < font.big.length;  z++) { this.m[z + font.small.length] = font.big[z]; }
		for(var z = 0; z < rom.rom.length;   z++) { this.m[0x200+z] = rom.rom[z]; }
		for(var z = 0; z < 16;               z++) { this.v[z] = 0; }
		for(var z = 0; z < 16;               z++) { this.pattern[z] = 0; }

		// initialize interpreter state
		this.r = [];
		this.pc = 0x200;
		this.i  = 0;
		this.dt = 0;
		this.st = 0;
		this.hires = false;
		this.plane = 1;

		// initialize control/debug state
		this.keys = {};
		this.waiting = false;
		this.waitReg = -1;
		this.halted = false;
		this.breakpoint = false;
		this.stack_breakpoint = -1;
		this.metadata = rom;
		this.tickCounter = 0;
		this.profile_data = {};
	}

	this.writeCarry = function(dest, value, flag) {
		this.v[dest] = (value & 0xFF);
		this.v[0xF] = flag ? 1 : 0;
		if (this.vfOrderQuirks) {
			this.v[dest] = (value & 0xFF);
		}
	}

	this.math = function(x, y, op) {
		// basic arithmetic opcodes
		switch(op) {
			case 0x0: this.v[x]  = this.v[y]; break;
			case 0x1: this.v[x] |= this.v[y]; if (this.logicQuirks) this.v[0xF]=0; break;
			case 0x2: this.v[x] &= this.v[y]; if (this.logicQuirks) this.v[0xF]=0; break;
			case 0x3: this.v[x] ^= this.v[y]; if (this.logicQuirks) this.v[0xF]=0; break;
			case 0x4:
				var t = this.v[x]+this.v[y];
				this.writeCarry(x, t, (t > 0xFF));
				break;
			case 0x5:
				var t = this.v[x]-this.v[y];
				this.writeCarry(x, t, (this.v[x] >= this.v[y]));
				break;
			case 0x7:
				var t = this.v[y]-this.v[x];
				this.writeCarry(x, t, (this.v[y] >= this.v[x]));
				break;
			case 0x6:
				if (this.shiftQuirks) { y = x; }
				var t = this.v[y] >> 1;
				this.writeCarry(x, t, (this.v[y] & 0x1));
				break;
			case 0xE:
				if (this.shiftQuirks) { y = x; }
				var t = this.v[y] << 1;
				this.writeCarry(x, t, ((this.v[y] >> 7) & 0x1));
				break;
			default:
				haltBreakpoint("unknown math opcode "+op.toString(16).toUppercase());
		}
	}

	this.misc = function(x, rest) {
		// miscellaneous opcodes
		switch(rest) {
			case 0x01:
				this.plane = (x & 0x3);
				break;
			case 0x02:
				for(var z = 0; z < 16; z++) {
					this.pattern[z] = this.m[this.i+z];
				}
				break;
			case 0x07: this.v[x] = this.dt; break;
			case 0x0A: this.waiting = true; this.waitReg = x; break;
			case 0x15: this.dt = this.v[x]; break;
			case 0x18: this.buzzTrigger(this.v[x], this.st); this.st = this.v[x]; break;
			case 0x1E: this.i = (this.i + this.v[x])&0xFFFF; break;
			case 0x29: this.i = ((this.v[x] & 0xF) * 5); break;
			case 0x30: this.i = ((this.v[x] & 0xF) * 10 + fontsets[this.fontStyle].small.length); break;
			case 0x33:
				this.m[this.i]   = Math.floor(this.v[x]/100)%10;
				this.m[this.i+1] = Math.floor(this.v[x]/10)%10;
				this.m[this.i+2] = this.v[x]%10;
				break;
			case 0x55:
				for(var z = 0; z <= x; z++) { this.m[this.i+z] = this.v[z]; }
				if (!this.loadStoreQuirks) { this.i = (this.i+x+1)&0xFFFF; }
				break;
			case 0x65:
				for(var z = 0; z <= x; z++) { this.v[z] = this.m[this.i+z]; }
				if (!this.loadStoreQuirks) { this.i = (this.i+x+1)&0xFFFF; }
				break;
			case 0x75:
				for(var z = 0; z <= x; z++) { this.flags[z] = this.v[z]; }
				this.exportFlags(this.flags);
				break;
			case 0x85:
				this.flags = this.importFlags();
				if (typeof this.flags == "undefined" || this.flags == null) {
					this.flags = [0, 0, 0, 0, 0, 0, 0, 0];
				}
				for(var z = 0; z <= x; z++) { this.v[z] = this.flags[z]; }
				break;
			default:
				haltBreakpoint("unknown misc opcode "+rest.toString(16).toUppercase());
		}
	}

	this.sprite = function sprite(x, y, len) {
		this.v[0xF] = 0x0;
		var rowSize = this.hires ? 128 : 64;
		var colSize = this.hires ?  64 : 32;
		var i = this.i;
		for(var layer = 0; layer < 2; layer++) {
			if ((this.plane & (layer+1)) == 0) { continue; }
			if (len == 0) {
				// draw a SuperChip 16x16 sprite
				for(var a = 0; a < 16; a++) {
					for(var b = 0; b < 16; b++) {
						var target = ((x+b) % rowSize) + ((y+a) % colSize)*rowSize;
						var source = ((this.m[i+(a*2)+(b > 7 ? 1:0)] >> (7-(b%8))) & 0x1) != 0;
						if (this.clipQuirks) {
							if ((x%rowSize)+b>=rowSize || (y%colSize)+a>=colSize) { source = 0; }
						}
						if (!source) { continue; }
						if (this.p[layer][target]) { this.p[layer][target] = 0; this.v[0xF] = 0x1; }
						else { this.p[layer][target] = 1; }
					}
				}
				i += 32;
			}
			else {
				// draw a Chip8 8xN sprite
				for(var a = 0; a < len; a++) {
					for(var b = 0; b < 8; b++) {
						var target = ((x+b) % rowSize) + ((y+a) % colSize)*rowSize;
						var source = ((this.m[i+a] >> (7-b)) & 0x1) != 0;
						if (this.clipQuirks) {
							if ((x%rowSize)+b>=rowSize || (y%colSize)+a>=colSize) { source = 0; }
						}
						if (!source) { continue; }
						if (this.p[layer][target]) { this.p[layer][target] = 0; this.v[0xF] = 0x1; }
						else { this.p[layer][target] = 1; }
					}
				}
				i += len;
			}
		}
	}

	this.call = function(nnn) {
		if (this.r.length >= 12) {
			haltBreakpoint("call stack overflow.");
		}
		this.r.push(this.pc);
		this.pc = nnn
	}

	this.jump0 = function(nnn) {
		if (this.jumpQuirks) { this.pc = nnn + this.v[(nnn >> 8)&0xF];  }
		else                 { this.pc = nnn + this.v[0]; }
	}

	this.machine = function(nnn) {
		if (nnn == 0x000) { this.halted = true; return; }
		haltBreakpoint("machine code is not supported.");
	}

	this.skip = function() {
		var op = (this.m[this.pc  ] << 8) | this.m[this.pc+1];
		this.pc += (op == 0xF000) ? 4 : 2;
	}

	this.opcode = function() {
		// Increment profilining data
		this.profile_data[this.pc] = (this.profile_data[this.pc] || 0) + 1;

		// decode the current opcode
		var op  = (this.m[this.pc  ] << 8) | this.m[this.pc+1];
		var o   = (this.m[this.pc  ] >> 4) & 0x00F;
		var x   = (this.m[this.pc  ]     ) & 0x00F;
		var y   = (this.m[this.pc+1] >> 4) & 0x00F;
		var n   = (this.m[this.pc+1]     ) & 0x00F;
		var nn  = (this.m[this.pc+1]     ) & 0x0FF;
		var nnn = op & 0xFFF;
		this.pc += 2;

		// execute a simple opcode
		if (op == 0x00E0) {
			// clear
			for(var layer = 0; layer < 2; layer++) {
				if ((this.plane & (layer+1)) == 0) { continue; }
				for(var z = 0; z < this.p[layer].length; z++) {
					this.p[layer][z] = 0;
				}
			}
			return;
		}
		if (op == 0x00EE) {
			// return
			this.pc = this.r.pop();
			return;
		}
		if ((op & 0xF0FF) == 0xE09E) {
			// if -key
			if (Object.keys(keymap[this.v[x]]||{}).some(x => x in this.keys)) { this.skip(); }
			return;
		}
		if ((op & 0xF0FF) == 0xE0A1) {
			// if key
			if (!Object.keys(keymap[this.v[x]]||{}).some(x => x in this.keys)) { this.skip(); }
			return;
		}
		if ((op & 0xFFF0) == 0x00C0) {
			// scroll down n pixels
			var rowSize = this.hires ? 128 : 64;
			for(var layer = 0; layer < 2; layer++) {
				if ((this.plane & (layer+1)) == 0) { continue; }
				for(var z = this.p[layer].length - 1; z >= 0; z--) {
					this.p[layer][z] = (z >= rowSize * n) ? this.p[layer][z - (rowSize * n)] : 0;
				}
			}
			return;
		}
		if ((op & 0xFFF0) == 0x00D0) {
			// scroll up n pixels
			var rowSize = this.hires ? 128 : 64;
			for(var layer = 0; layer < 2; layer++) {
				if ((this.plane & (layer+1)) == 0) { continue; }
				for(var z = 0; z < this.p[layer].length; z++) {
					this.p[layer][z] = (z < (this.p[layer].length - rowSize * n)) ? this.p[layer][z + (rowSize * n)] : 0;
				}
			}
			return;
		}
		if (op == 0x00FB) {
			// scroll right 4 pixels
			var rowSize = this.hires ? 128 : 64;
			for(var layer = 0; layer < 2; layer++) {
				if ((this.plane & (layer+1)) == 0) { continue; }
				for(var a = 0; a < this.p[layer].length; a += rowSize) {
					for(var b = rowSize-1; b >= 0; b--) {
						this.p[layer][a + b] = (b > 3) ? this.p[layer][a + b - 4] : 0;
					}
				}
			}
			return;
		}
		if (op == 0x00FC) {
			// scroll left 4 pixels
			var rowSize = this.hires ? 128 : 64;
			for(var layer = 0; layer < 2; layer++) {
				if ((this.plane & (layer+1)) == 0) { continue; }
				for(var a = 0; a < this.p[layer].length; a += rowSize) {
					for(var b = 0; b < rowSize; b++) {
						this.p[layer][a + b] = (b < rowSize - 4) ? this.p[layer][a + b + 4] : 0;
					}
				}
			}
			return;
		}
		if (op == 0x00FD) {
			// exit
			this.halted = true;
			this.exitVector();
			return;
		}
		if (op == 0x00FE) {
			// lores
			this.hires = false;
			this.p = [[], []];
			for(var z = 0; z < 32*64; z++) { this.p[0][z] = 0; this.p[1][z] = 0; }
			return;
		}
		if (op == 0x00FF) {
			// hires
			this.hires = true;
			this.p = [[], []];
			for(var z = 0; z < 64*128; z++) { this.p[0][z] = 0; this.p[1][z] = 0; }
			return;
		}
		if (op == 0xF000) {
			// long memory reference
			this.i = ((this.m[this.pc] << 8) | (this.m[this.pc+1])) & 0xFFFF;
			this.pc += 2;
			return;
		}

		if (o == 0x5 && n != 0) {
			if (n == 2) {
				// save range
				var dist = Math.abs(x - y);
				if (x < y) { for(var z = 0; z <= dist; z++) { this.m[this.i+z] = this.v[x+z]; }}
				else       { for(var z = 0; z <= dist; z++) { this.m[this.i+z] = this.v[x-z]; }}
				return;
			}
			else if (n == 3) {
				// load range
				var dist = Math.abs(x - y);
				if (x < y) { for(var z = 0; z <= dist; z++) { this.v[x+z] = this.m[this.i+z]; }}
				else       { for(var z = 0; z <= dist; z++) { this.v[x-z] = this.m[this.i+z]; }}
				return;
			}
			else {
				haltBreakpoint("unknown opcode "+op.toString(16).toUppercase());
			}
		}
		if (o == 0x9 && n != 0) {
			haltBreakpoint("unknown opcode "+op.toString(16).toUppercase());
		}

		// dispatch complex opcodes
		switch(o) {
			case 0x0: this.machine(nnn);                            break;
			case 0x1: this.pc = nnn;                                break;
			case 0x2: this.call(nnn);                               break;
			case 0x3: if (this.v[x] == nn)        { this.skip(); }  break;
			case 0x4: if (this.v[x] != nn)        { this.skip(); }  break;
			case 0x5: if (this.v[x] == this.v[y]) { this.skip(); }  break;
			case 0x6: this.v[x] = nn;                               break;
			case 0x7: this.v[x] = (this.v[x] + nn) & 0xFF;          break;
			case 0x8: this.math(x, y, n);                           break;
			case 0x9: if (this.v[x] != this.v[y]) { this.skip(); }  break;
			case 0xA: this.i = nnn;                                 break;
			case 0xB: this.jump0(nnn);                              break;
			case 0xC: this.v[x] = (Math.random()*256)&nn;           break;
			case 0xD: this.sprite(this.v[x], this.v[y], n);         break;
			case 0xF: this.misc(x, nn);                             break;
			default: haltBreakpoint("unknown opcode "+o.toString(16).toUppercase());
		}
	}

	this.tick = function() {
		if (this.halted) { return; }
		this.tickCounter++;
		try {
			this.opcode();
		}
		catch(err) {
			console.log("halted: " + err);
			this.halted = true;
		}
	}
}
</script>
<script>"use strict";

////////////////////////////////////
//
//   Emulator Execution
//
////////////////////////////////////

//must be set > 0
var scaleFactor = 5;
//dom id for canvas element
var renderTarget = "target";

const optionFlags = [
	"tickrate",
	"fillColor",
	"fillColor2",
	"blendColor",
	"backgroundColor",
	"buzzColor",
	"quietColor",
	"shiftQuirks",
	"loadStoreQuirks",
	"vfOrderQuirks",
	"clipQuirks",
	"vBlankQuirks",
	"jumpQuirks",
	"screenRotation",
	"maxSize",
	"touchInputMode",
	"logicQuirks",
	"fontStyle",
]
function unpackOptions(emulator, options) {
	optionFlags.forEach(x => { if (x in options) emulator[x] = options[x] })
	if (options["enableXO"]) emulator.maxSize = 65024 // legacy option
}
function packOptions(emulator) {
	const r = {}
	optionFlags.forEach(x => r[x] = emulator[x])
	return r
}

function setRenderTarget(scale, canvas) {
	scaleFactor = scale;
	renderTarget = canvas;
	var c = document.getElementById(canvas);

	// Remove any existing previous delta frame so first frame is always drawn:
	c.last = undefined;

	var w  = scaleFactor * 128;
	var h  = scaleFactor *  64;

	if (emulator.screenRotation == 90 || emulator.screenRotation == 270) {
		c.width  = h;
		c.height = w;
	}
	else {
		c.width  = w;
		c.height = h;
	}
}

function setTransform(emulator, g) {
	g.setTransform(1, 0, 0, 1, 0, 0);
	var x = scaleFactor * 128;
	var y = scaleFactor *  64;
	switch(emulator.screenRotation) {
		case 90:
			g.rotate(0.5 * Math.PI);
			g.translate(0, -y);
			break;
		case 180:
			g.rotate(1.0 * Math.PI);
			g.translate(-x, -y);
			break;
		case 270:
			g.rotate(1.5 * Math.PI);
			g.translate(-x, 0);
			break;
		default:
			console.assert(emulator.screenRotation === 0, 'Screen rotation not set to 0, 90, 180, or 270. Treating as 0.')
	}
}


function arrayEqual(a, b) {
	var length = a.length;
	if (length !== b.length) { return false; }
	for (var i = 0; i < length; i++) {
		if (a[i] !== b[i]) { return false; }
	}
	return true;
}

function getColor(id) {
	switch(id) {
		case 0: return emulator.backgroundColor;
		case 1: return emulator.fillColor;
		case 2: return emulator.fillColor2;
		case 3: return emulator.blendColor;
	}
	throw "invalid color: " + id;
}

function renderDisplay(emulator) {
	var c = document.getElementById(renderTarget);

	// Canvas rendering can be expensive. Exit out early if nothing has changed.
	var colors = [emulator.backgroundColor, emulator.fillColor, emulator.fillColor2, emulator.blendColor];
	if (c.last !== undefined) {
		if (arrayEqual(c.last.p[0], emulator.p[0]) && arrayEqual(c.last.p[1], emulator.p[1])
				&& arrayEqual(c.last.colors, colors)) {
			return;
		}
		if (c.last.hires !== emulator.hires)
			c.last = undefined;  // full redraw when switching resolution
	}
	var g = c.getContext("2d");
	setTransform(emulator, g);
	var w      = emulator.hires ? 128         : 64;
	var h      = emulator.hires ? 64          : 32;
	var size   = emulator.hires ? scaleFactor : scaleFactor*2;
	var lastPixels = c.last !== undefined? c.last.p: [[], []]

	g.scale(size, size)
	var z = 0;
	for(var y = 0; y < h; ++y) {
		for(var x = 0; x < w; ++x, ++z) {
			var oldColorIdx = lastPixels[0][z] + (lastPixels[1][z] << 1);
			var colorIdx = emulator.p[0][z] + (emulator.p[1][z] << 1);
			if (oldColorIdx !== colorIdx) {
				g.fillStyle = getColor(colorIdx);
				g.fillRect(x, y, 1, 1);
			}
		}
	}
	g.scale(1, 1) //restore scale to 1,1 just in case

	c.last = {
		colors: colors,
		p: [emulator.p[0].slice(), emulator.p[1].slice()],
		hires: emulator.hires,
	};
}

////////////////////////////////////
//
//   Audio Playback
//
////////////////////////////////////

var audio;
var audioNode;
var audioSource;
var audioData;

var AudioBuffer = function(buffer, duration) {
	if (!(this instanceof AudioBuffer)) {
		return new AudioBuffer(buffer, duration);
	}

	this.pointer = 0;
	this.buffer = buffer;
	this.duration = duration;
}

AudioBuffer.prototype.write = function(buffer, index, size) {
	size = Math.max(0, Math.min(size, this.duration))
	if (!size) { return size; }

	this.duration -= size;
	var bufferSize = this.buffer.length;
	var end = index + size;

	for(var i = index; i < end; ++i) {
		buffer[i] = this.buffer[this.pointer++];
		this.pointer %= bufferSize;
	}

	return size;
}

AudioBuffer.prototype.dequeue = function(duration) {
	this.duration -= duration;
}

var FREQ = 4000;
var TIMER_FREQ = 60;
var SAMPLES = 16;
var BUFFER_SIZE = SAMPLES * 8


function audioEnable() {
	// this will only work if called directly from a user-generated input handler:
	if (audio && audio.state == 'suspended') audio.resume()
}

function audioSetup() {
	if (!audio) {
		if (typeof AudioContext !== 'undefined') {
			audio = new AudioContext();
		}
		else if (typeof webkitAudioContext !== 'undefined') {
			audio = new webkitAudioContext();
		}
	}
	audioEnable()
	if (audio && !audioNode) {
		audioNode = audio.createScriptProcessor(4096, 1, 1);
		audioNode.onaudioprocess = function(audioProcessingEvent) {
			var outputBuffer = audioProcessingEvent.outputBuffer;
			var outputData = outputBuffer.getChannelData(0);
			var samples_n = outputBuffer.length;

			var index = 0;
			while(audioData.length && index < samples_n) {
				var size = samples_n - index;
				var written = audioData[0].write(outputData, index, size);
				index += written;
				if (written < size) {
					audioData.shift();
				}
			}

			while(index < samples_n) {
				outputData[index++] = 0;
			}
			//the last one can be long sound with high value of buzzer, so always keep it
			if (audioData.length > 1) {
				var audioDataSize = 0;
				var audioBufferSize = audioNode.bufferSize;
				audioData.forEach(function(buffer) { audioDataSize += buffer.duration; })
				while(audioDataSize > audioBufferSize && audioData.length > 1) {
					audioDataSize -= audioData.shift().duration;
				}
			}
		}
		audioData = [];
		audioNode.connect(audio.destination);
		return true;
	}
	if (audio && audioNode) { return true; }
	return false;
}

function stopAudio() {
	if (!audio) { return; }
	if (audioNode) {
		audioNode.disconnect();
		audioNode = null;
	}
	audioData = [];
}

var VOLUME = 0.25;

function playPattern(soundLength, buffer, remainingTicks) {
	if (!audio) { return; }
	audioEnable()

	var samples = Math.floor(BUFFER_SIZE * audio.sampleRate / FREQ);
	var audioBuffer = new Array(samples);
	if (remainingTicks && audioData.length > 0) {
		audioData[audioData.length - 1].dequeue(Math.floor(remainingTicks * audio.sampleRate / TIMER_FREQ));
	}

	for(var i = 0; i < samples; ++i) {
		var srcIndex = Math.floor(i * FREQ / audio.sampleRate);
		var cell = srcIndex >> 3;
		var bit = srcIndex & 7;
		audioBuffer[i] = (buffer[srcIndex >> 3] & (0x80 >> bit)) ? VOLUME: 0;
	}
	audioData.push(new AudioBuffer(audioBuffer, Math.floor(soundLength * audio.sampleRate / TIMER_FREQ)));
}

function escapeHtml(str) {
    var div = document.createElement('div');
    div.appendChild(document.createTextNode(str));
    return div.innerHTML;
}
</script>
<script>/**
* Adaptive Input
**/

const ael = (element, event, listener) => element.addEventListener   (event, listener, { passive:false })
const rel = (element, event, listener) => element.removeEventListener(event, listener, { passive:false })
const pd  = event => (event.preventDefault(),event.stopPropagation())

const VIP_HEX  = '123c456d789ea0bf'.split('')
const VIP_KEYS = VIP_HEX.map(x => parseInt(x,16))

const GAMEPAD_STYLES = `
.gamepad{
  position:absolute;
  top:10%;
  left:0px;
  width:100%;
  height:90%;
  opacity:0.3;
  user-select: none;
  -webkit-user-select: none;
}
.gamepad .dpad{
  position:absolute;
  bottom: 50px;
  left:   50px;
  width:  250px;
  height: 250px;
  background: gray;
  border-radius: 50%;
  overflow:hidden;
}
.gamepad .stick{
  display:none;
  position:absolute;
  border-radius: 50%;
  width:100px;
  height:100px;
  margin-left:-50px;
  margin-top:-50px;
}
.gamepad .buttons{
  position:absolute;
  bottom: 50px;
  right:  50px;
  width:  250px;
  height: 250px;
}
.gamepad .gamebutton{
  position:absolute;
  width:  125px;
  height: 125px;
  background:gray;
  border-radius:50%;
  overflow:hidden;
  line-height: 125px;
  font-size:50px;
  font-weight:bold;
  color:darkgray;
  text-align:center;
}
.gamepad .dpad.active .stick {display:block;background:#444}
.gamepad .gamebutton.active{background:#444;}
.gamepad .gamebutton.b{left:0;bottom:0;}
.gamepad .gamebutton.a{right:0;top:0;}
`
const VIP_STYLES = `
.vip-pad {display:flex;flex-direction:column;align-items:center;z-index:2000;}
.vip-pad .keypad {display:flex;flex-direction:column;margin-top:10px;}
.vip-pad .keypad>div {display:flex;flex-direction:row;}
.vip-pad .keypad>div>div {
  -webkit-user-select: none;
  user-select: none;
  background:gray;
  width: 100px;
  height: 51px;
  display: flex;
  justify-content: center;
  align-items: center;
  margin: 1px;
}
.vip-pad .keypad>div>div:active,
.vip-pad .keypad>div>div.active {background:black; border:1px solid white;margin:0px;}
`

const INPUT_MODULES = {
  /**
  * An invisible set of gesture recognizers,
  * giving directional input and an action for taps.
  **/
  swipe: {
    install: (screen,up,down,options) => {

      let vdirs      = []
      let direction  = { i:null, sx:0, sy:0, lx:0, ly:0 }
      let action1    = {}
      let taptimeout = null

      const updateStick = _ => {
        // find the relative position of the stick to its starting point
        const cx = direction.lx - direction.sx
        const cy = direction.ly - direction.sy

        // update the virtual direction buttons
        let t = []
        const DEAD_ZONE = 30
        if (Math.abs(cx) > DEAD_ZONE) t.push(cx < 0 ? options.left : options.right)
        if (Math.abs(cy) > DEAD_ZONE) t.push(cy < 0 ? options.up   : options.down)
        vdirs.forEach(x => (t    .indexOf(x)<0) && up  (x)) // clear keys no longer held
        t    .forEach(x => (vdirs.indexOf(x)<0) && down(x)) // push keys that were not held before
        vdirs = t
      }
      const tapDown= i => {
        if (Object.keys(action1).length == 0) down(options.action1)
        action1[i] = true
        if (i == direction.i) { direction = { i:null, sx:0, sy:0, lx:0, ly:0 } }
        taptimeout = null
      }
      const start = e => {
        const t = e.touches[0]
        const i = t.identifier
        // a single-touch is either directional or a tap...
        if (direction.i != null) {
          tapDown(i)
        }
        else {
          direction.i  = i
          direction.sx = t.clientX
          direction.sy = t.clientY
          direction.lx = t.clientX
          direction.ly = t.clientY
          taptimeout = setTimeout(_ => tapDown(i), 100)
        }
        updateStick(),pd(e)
      }
      const move = e => {
        for(let z = 0; z < e.changedTouches.length; z++) {
          const t = e.changedTouches[z]
          const i = t.identifier
          if (i == direction.i) {
            if (taptimeout != null) { clearTimeout(taptimeout); taptimeout = null }
            direction.lx = t.clientX
            direction.ly = t.clientY
          }
        }
        updateStick(),pd(e)
      }
      const end = e => {
        let r1 = false
        for(let z = 0; z < e.changedTouches.length; z++) {
          const t = e.changedTouches[z]
          const i = t.identifier
          if (i == direction.i) {
            if (taptimeout != null) {
              // cancel a short tap
              clearTimeout(taptimeout); taptimeout = null
              down(options.action1)
              setTimeout(_ => up(options.action1), 50)
            }
            direction = { i:null, sx:0, sy:0, lx:0, ly:0 }
          }
          if (i in action1) {
            delete action1[i]
            r1=true
          }
        }
        if (r1 && Object.keys(action1).length == 0) up(options.action1)
        updateStick(),pd(e)
      }
      ael(screen, 'touchstart', start)
      ael(screen, 'touchmove',  move)
      ael(screen, 'touchend',   end)
      screen.uninstallSwipe = _ => {
        rel(screen, 'touchstart', start)
        rel(screen, 'touchmove',  move)
        rel(screen, 'touchend',   end)
      }
    },
    remove: (screen) => {
      screen.uninstallSwipe()
      delete screen.uninstallSwipe
    }
  },

  /**
  * A virtual gamepad overlay with two remappable action keys.
  **/
  gamepad: {
    install: (screen,up,down,options) => {
      // build the UI
      if (document.querySelector('.gamepad')) return
      const root = document.createElement('div')
      root.classList.add('gamepad')
      root.innerHTML = `
      <div class='dpad'><div class='stick'></div></div>
      <div class='buttons'><div class='gamebutton b'>B</div><div class='gamebutton a'>A</div></div>
      <style>${GAMEPAD_STYLES}</style>`
      screen.parentElement.append(root)

      let vdirs      = []
      let directions = {}
      let buttons    = {}
      const pad   = document.querySelector('.gamepad .dpad')
      const stick = document.querySelector('.gamepad .dpad .stick')
      const a     = document.querySelector('.gamepad .gamebutton.a')
      const b     = document.querySelector('.gamepad .gamebutton.b')

      const updateStick = _ => {
        // find centroid of d-pad touchpoints ({0,0} if no touchpoints)
        const touches = Object.values(directions)
        let cx = 0, cy = 0, r = pad.getBoundingClientRect(), sr = stick.getBoundingClientRect()
        touches.forEach(t => (cx+=t.x, cy+=t.y))
        cx /= touches.length,         cy /= touches.length
        cx -= (r.left + (r.width/2)), cy -= (r.top + (r.height/2))

        // position the virtual stick, clamped within dpad
        const ca = Math.atan2(cy, cx)
        const cd = Math.min(Math.sqrt(cx*cx + cy*cy), (r.width/2)-(sr.width/2))
        stick.style.left = ((Math.cos(ca)*cd)+(r.width /2)|0)+'px'
        stick.style.top  = ((Math.sin(ca)*cd)+(r.height/2)|0)+'px'

        // update the virtual direction buttons
        let t = []
        const DEAD_ZONE = 30
        if (Math.abs(cx) > DEAD_ZONE) t.push(cx < 0 ? options.left : options.right)
        if (Math.abs(cy) > DEAD_ZONE) t.push(cy < 0 ? options.up   : options.down)
        vdirs.forEach(x => (t    .indexOf(x)<0) && up  (x)) // clear keys no longer held
        t    .forEach(x => (vdirs.indexOf(x)<0) && down(x)) // push keys that were not held before
        vdirs = t
      }

      const start = e => {
        for(let z = 0; z<e.touches.length; z++) {
          const t = e.touches[z]
          const i = t.identifier
          if (t.target == a) {
            t.target.classList.add('active')
            buttons[i]=options.action1
            down(options.action1)
          }
          if (t.target == b) {
            t.target.classList.add('active')
            buttons[i]=options.action2
            down(options.action2)
          }
          if (t.target == pad) {
            t.target.classList.add('active')
            directions[i]={x:t.clientX, y:t.clientY}
          }
        }
        updateStick(),pd(e)
      }
      const move = e => {
        for(let z = 0; z<e.changedTouches.length; z++) {
          const t = e.changedTouches[z]
          const i = t.identifier
          if (i in directions) directions[i]={x:t.clientX, y:t.clientY}
        }
        updateStick(),pd(e)
      }
      const end = e => {
        for(let z = 0; z<e.changedTouches.length; z++) {
          const t = e.changedTouches[z]
          const i = t.identifier
          if (i in buttons) {
            t.target.classList.remove('active')
            up(buttons[i])
            delete buttons[i]
          }
          if (i in directions) {
            t.target.classList.remove('active')
            delete directions[i]
          }
        }
        updateStick(),pd(e)
      }

      ael(a,   'touchstart', start)
      ael(a,   'touchend',   end  )
      ael(b,   'touchstart', start)
      ael(b,   'touchend',   end  )
      ael(pad, 'touchstart', start)
      ael(pad, 'touchmove',  move )
      ael(pad, 'touchend',   end  )
    },
    remove: (screen) => {
      document.querySelector('.gamepad').remove()
    },
  },

  /**
  * Treat the entire screen, or a centered square region, as invisible buttons,
  * mapped out in the order of the VIP hex keypad.
  **/
  seg16: {
    install: (screen,up,down,options) => {
      const tmap = {}
      const pointToKey = touch => {
        // poll this for each point, as it may vary over time,
        // and experimentally it's never right initially...
        const r = screen.getBoundingClientRect()
        if (options.mode == 'center') {
          if (r.width > r.height) { r.x += (r.width - r.height)/2; r.width = r.height }
          else                    { r.y += (r.height - r.width)/2; r.height = r.width }
        }
        const x = touch.clientX - r.x
        const y = touch.clientY - r.y
        if (x < 0 || x > r.width || y < 0 || y > r.height) return null
        const tx = Math.floor(x / (r.width /4))
        const ty = Math.floor(y / (r.height/4))
        return VIP_KEYS[tx + (4 * ty)]
      }
      const start = e => {
        for(let z=0; z<e.touches.length; z++) {
          const i = e.touches[z].identifier
          const k = pointToKey(e.touches[z])
          if (k != null) down(k)
          tmap[i]=k
        }
        pd(e)
      }
      const move = e => {
        for(let z=0; z<e.touches.length; z++) {
          const i = e.touches[z].identifier
          const k = pointToKey(e.touches[z])
          if (tmap[i] == k) continue       // same cell, nothing to do.
          if (tmap[i] != null) up(tmap[i]) // release old key, if any
          if (k != null)       down(k)     // press new key, if any
          tmap[i]=k
        }
        pd(e)
      }
      const end = e => {
        for(let z=0; z<e.changedTouches.length; z++) {
          const i = e.changedTouches[z].identifier
          const k = pointToKey(e.changedTouches[z])
          if (tmap[i] != null) up(tmap[i])
          tmap[i]=null
        }
        pd(e)
      }
      ael(screen, 'touchstart', start)
      ael(screen, 'touchmove',  move )
      ael(screen, 'touchend',   end  )
      screen.uninstallSeg16 = _ => {
        rel(screen, 'touchstart', start)
        rel(screen, 'touchmove',  move )
        rel(screen, 'touchend',   end  )
      }
    },
    remove:  (screen) => {
      screen.uninstallSeg16()
      delete screen.uninstallSeg16
    },
  },

  /**
  * Provide a visible 4x4 representation of the VIP hex keypad.
  **/
  vip: {
    install: (screen,up,down,options) => {
      if (document.querySelector('.vip-pad')) return
      const root = document.createElement('div')
      root.classList.add('vip-pad')
      root.innerHTML = `<div class='keypad'>
        ${[0,1,2,3].map(r=>`<div>${[0,1,2,3].map(c=>`<div>${VIP_HEX[c+(r*4)].toUpperCase()}</div>`).join('')}</div>`).join('')}
      </div>
      <style>${VIP_STYLES}</style>`
      if (screen.parentElement == document.body) { screen.parentElement.append(root) }
      else { screen.parentElement.parentElement.append(root) }
      const buttons = []
      document.querySelectorAll('.vip-pad .keypad>div>div').forEach(x=>buttons.push(x)) // make an actual Array
      const held = {}
      const start = e => {
        for(let z=0; z<e.touches.length; z++) {
          const t = e.touches[z]
          const i = t.identifier
          const k = VIP_KEYS[buttons.indexOf(t.target)]
          t.target.classList.add('active')
          down(k)
          held[i]=k
        }
        pd(e)
      }
      const end = e => {
        for(let z = 0; z<e.changedTouches.length; z++) {
          const t = e.changedTouches[z]
          const i = t.identifier
          if (held[i]) { up(held[i]); delete held[i] }
          t.target.classList.remove('active')
        }
        pd(e)
      }
      buttons.forEach(b => {
        ael(b, 'touchstart', start)
        ael(b, 'touchend',   end  )
      })
    },
    remove:  (screen) => {
      document.querySelector('.vip-pad').remove()
    },
  },
}

let adaptiveControlsInstalled = null

function injectAdaptiveControls(type, screen, keyup, keydown) {
  let options = {
    up:      5,
    down:    8,
    left:    7,
    right:   9,
    action1: 6,
    action2: 4,
    mode:    'center', // or 'fill', used by seg16
  }
  const lookup = vk => Object.keys(keymap[vk])[0]
  const install = _ => {
    rel(screen, 'touchstart', install)
    adaptiveControlsInstalled = type
    INPUT_MODULES[type].install(
      screen,
      key => keyup  ({ key:lookup(key), preventDefault:_=>_ }),
      key => keydown({ key:lookup(key), preventDefault:_=>_ }),
      options
    )
  }
  // uninstall anything that's already there:
  rel(screen, 'touchstart', install)
  if (adaptiveControlsInstalled) INPUT_MODULES[adaptiveControlsInstalled].remove(screen)

  if (type == 'none') return
  if (type == 'seg16fill') { type='seg16'; options.mode='fill' }
  // defer installing adaptive input until we actually see
  // an input event from the user:
  ael(screen, 'touchstart', install)
}
</script>
<body><canvas id='target' width=512 height=256></canvas></body>
<style>body{margin:0px;display:flex;flex-direction:column;align-items:center;justify-content:center;height:100%;}</style>
<script>
const emulator = new Emulator()
unpackOptions(emulator, data.options)
setRenderTarget(data.options.displayScale || 4, 'target')
emulator.init({rom:data.rom})
emulator.importFlags = _ => getPref('octoFlagRegisters')
emulator.exportFlags = f => setPref('octoFlagRegisters',f)
emulator.buzzTrigger = (ticks,rest)=> playPattern(ticks, emulator.pattern, rest)
const kd = e=>{
	if (!audio) audioSetup()
	if (!(e.key in emulator.keys)) emulator.keys[e.key]=true
	e.preventDefault()
}
const ku = e=>{
	if (e.key in emulator.keys) delete emulator.keys[e.key]
	if (!emulator.waiting) return
	const kindex = keymapInverse[e.key]
	if (kindex != undefined) {
		emulator.waiting = false
		emulator.v[emulator.waitReg] = kindex
	}
	e.preventDefault()
}
window.addEventListener('keydown',kd,false)
window.addEventListener('keyup',ku,false)
intervalHandle = setInterval(_=>{
	if (emulator.halted) return
	for(var z = 0; (z<emulator.tickrate) && (!emulator.waiting); z++) emulator.tick()
	if (emulator.dt > 0) emulator.dt--
	if (emulator.st > 0) emulator.st--
	renderDisplay(emulator)
	document.body.style.backgroundColor = emulator.st?emulator.buzzColor:emulator.quietColor
}, 1000/60)

injectAdaptiveControls(emulator.touchInputMode,document.getElementById('target'),ku,kd)
</script>
